---
layout: page
title: Базовый синтаксис
---

# Базовый синтаксис

Добро пожаловать на первый настоящий урок курса! Сегодня мы начнём знакомство с языком Scala — узнаем, как он устроен, чем отличается от других языков и напишем свои первые строки кода. Не переживайте, если что-то покажется незнакомым: каждую тему мы разберём подробно, а к концу урока у вас сложится цельная картина основ языка.

## Содержание

- [Парадигмы программирования](#парадигмы-программирования)
- [Особенности Scala](#особенности-scala)
- [Литералы и операции](#литералы-и-операции)
- [Переменные](#переменные)
- [Функции](#функции)
- [Условный переход и циклы](#условный-переход-и-циклы)
- [Классы и типы](#классы-и-типы)
- [Option](#option)
- [Структура проекта](#структура-проекта)

---

## Парадигмы программирования

Прежде чем погружаться в синтаксис, давайте поговорим о том, **как вообще можно думать о программировании**. Существует несколько основных подходов — их называют парадигмами. Scala интересна тем, что поддерживает сразу несколько из них. Это значит, что вы можете выбирать стиль, наиболее подходящий для конкретной задачи.

### Императивное программирование

Это самый привычный подход, с которого начинают многие программисты. Вы пишете **последовательность команд** — шаг за шагом указываете компьютеру, что делать. Состояние программы меняется с каждой строкой:

```scala
def sum(list: List[Vector]): Vector = {
  var sum: Vector = new Vector(0, 0)
  for (vector <- list)
    sum = sum + vector
  sum
}
```

Здесь мы завели переменную `sum`, а затем в цикле постоянно её обновляем. Это типичный императивный подход: «возьми переменную, пройдись по списку, на каждом шаге измени переменную».

### Объектно-ориентированное программирование

В ООП мы группируем данные и поведение внутри **объектов**. Каждый объект отвечает за своё состояние и предоставляет методы для работы с ним:

```scala
class Car() {
  private var distance: Int = 0

  def increaseDistance(): Unit = distance = distance + 1

  def zeroDistance(): Unit = distance = 0
}
```

Объект `Car` хранит пробег (`distance`) внутри себя и даёт наружу только два метода. Внешний код не может напрямую менять пробег — только через методы класса. Это называется **инкапсуляция**.

### Функциональное программирование

А вот здесь начинается самое интересное — именно этому подходу посвящён наш курс. В функциональном программировании мы стараемся **не менять состояние**, а описывать вычисления как цепочку преобразований данных:

```scala
def sum(list: List[Vector]): Vector =
  list.foldLeft(new Vector(0, 0))(_ + _)
```

Та же самая задача — сумма векторов — решена в одну строку, без единой переменной. Метод `foldLeft` берёт начальное значение и последовательно «сворачивает» список, применяя операцию сложения. Пока это может выглядеть непривычно, но по мере прохождения курса такой стиль станет для вас естественным.

---

## Особенности Scala

Теперь давайте разберёмся, что делает Scala особенным языком. У него есть несколько ключевых свойств, которые сильно влияют на то, как мы пишем код.

### Строгая типизация

Scala — **статически типизированный** язык. Это значит, что типы всех выражений проверяются ещё на этапе компиляции, до запуска программы. Если вы попытаетесь сложить строку с числом там, где это не предусмотрено — компилятор скажет об этом сразу, а не в рантайме.

Зачем это нужно? Строгая типизация даёт сразу несколько преимуществ:

- **Ранее обнаружение ошибок** — целый класс багов просто невозможен, потому что компилятор не даст скомпилировать некорректный код
- **Безопасный рефакторинг** — когда вы меняете сигнатуру функции, компилятор покажет все места, которые нужно обновить
- **Паттерн-матчинг** — компилятор может проверить, что вы обработали все варианты при сопоставлении с образцом

### Автоматический вывод типов

«Но постойте, — скажете вы, — если язык строго типизирован, не придётся ли повсюду писать типы?» Хороший вопрос! И ответ — нет. Компилятор Scala достаточно умён, чтобы **выводить типы автоматически**:

```scala
val question: String = "question of life"     // Явное указание типа
val answer = 42                                // Тип Int выведен автоматически

trait Pet
class Cat extends Pet
class Dog extends Pet

val pets = List(new Cat, new Dog)              // pets: List[Pet]
```

В последнем примере компилятор сам понял, что `Cat` и `Dog` — это подтипы `Pet`, и вывел общий тип `List[Pet]`. Вам не пришлось писать это руками.

На практике типы указывают явно в **публичных API** (параметры и возвращаемые типы функций), а внутри реализации полагаются на вывод типов. Это хороший баланс между читаемостью и краткостью.

### Всё возвращает значение

В Scala практически всё является **выражением**, то есть возвращает значение. Даже конструкция `if/else`:

```scala
val conditionalValue = if (1 > 2) 13 else 42   // conditionalValue: Int = 42

val value = print("42")                         // value: Unit = ()
```

Первая строка — `if` возвращает `42`, потому что условие `1 > 2` ложно. Вторая строка — `print` ничего полезного не возвращает, поэтому результат имеет тип `Unit` (аналог `void` в других языках). Запомните `Unit` — мы будем часто его встречать.

Это свойство языка очень удобно: вместо того чтобы заводить переменную и присваивать ей значение внутри `if`, вы можете сразу использовать результат выражения.

### Отказ от Null

В Scala принято сознательно **отказываться от `null`**. Вместо этого используется тип `Option`, который мы подробно разберём ближе к концу урока. Главная идея: если значение может отсутствовать, это должно быть отражено в типе. Это позволяет избавиться от `NullPointerException` — одной из самых частых ошибок в Java и многих других языках.

---

## Литералы и операции

Отлично, теперь давайте наконец писать код! Начнём с самого простого — **литералов**. Литерал — это значение, записанное прямо в коде:

```scala
1                    // Int — целое число
true                 // Boolean — логическое значение
"Hello, Scala"       // String — строка
```

Ничего сложного. Теперь посмотрим, что можно делать с этими значениями.

### Арифметические операции

Стандартная арифметика работает так, как вы и ожидаете:

```scala
1 + 2    // сложение → 3
2 - 1    // вычитание → 1
2 * 3    // умножение → 6
6 / 2    // деление → 3
5 % 2    // остаток от деления → 1
```

Строки тоже можно «складывать» — это называется конкатенация:

```scala
"Hello, " + "Scala"  // "Hello, Scala"
```

### Вызов методов и важный секрет Scala

Вы можете вызывать методы у значений через точку:

```scala
"Hello, Scala!".size   // 13
1.to(10)               // Range(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
```

А теперь — важный секрет. **В Scala операторы — это обычные методы.** Когда вы пишете `3 + 2`, на самом деле вы вызываете метод `+` у объекта `3` с аргументом `2`. Вот эквивалентные записи:

```scala
3 + 2      == 3.+(2)
1.to(10)   == (1 to 10)
```

Любой метод с одним параметром можно вызвать в инфиксной записи (без точки), и наоборот — любой «оператор» можно записать через точку. Это не просто синтаксический трюк — понимание этого факта поможет вам читать и писать идиоматичный код на Scala.

### Логические операции

Для полноты картины — логические операции, которые пригодятся в условиях:

```scala
1 > 1        // false
1 < 1        // false
1 >= 1       // true
1 <= 1       // true
!true        // false
true && false // false (логическое И)
true || false // true  (логическое ИЛИ)
```

---

## Переменные

Теперь, когда мы умеем записывать значения и выполнять операции, нужно научиться **сохранять результаты**. В Scala есть несколько способов объявить переменную, и выбор между ними — не просто вопрос стиля, а важное архитектурное решение.

### val — неизменяемая переменная

`val` — это ваш лучший друг в Scala. Значение присваивается один раз и больше **не может быть изменено**:

```scala
val radius = 10
val pi = 3.14159
pi * radius * radius   // 314.159
```

Если вы попытаетесь переприсвоить `val`, компилятор выдаст ошибку. Зачем такое ограничение? Потому что неизменяемые данные — это основа функционального программирования. Когда значение не может измениться, код становится предсказуемым: вы всегда знаете, что `radius` — это `10`, где бы в программе вы его ни встретили.

**Правило:** по умолчанию всегда используйте `val`. Переходите к `var` только тогда, когда изменяемость действительно необходима (а это бывает реже, чем вы думаете).

### var — изменяемая переменная

`var` позволяет менять значение после объявления:

```scala
var answer = -1
answer = 42
answer                 // 42
```

В императивном коде `var` встречается часто, но в функциональном стиле его стараются избегать. По мере прохождения курса вы увидите, что почти любую задачу можно решить без `var`.

### lazy val — ленивая инициализация

Иногда вычисление значения может быть дорогим, и вы хотите отложить его до момента, когда оно реально понадобится. Для этого есть `lazy val`:

```scala
val x = { println("x"); 15 }
lazy val y = { println("y"); 13 }
println("a")
y
```

Что выведет эта программа? Давайте разберём по шагам:

1. `val x` — вычисляется **сразу** при объявлении, поэтому в консоль выводится `x`
2. `lazy val y` — **не вычисляется** при объявлении, просто запоминается
3. `println("a")` — выводится `a`
4. `y` — вот теперь `y` нужен, и он вычисляется, выводя `y`

Итого в консоли:
```
x
a
y
```

### Сравнение val, var, lazy val и def

Чтобы всё уложилось в голове, вот таблица сравнения:

| Ключевое слово | Изменяемость | Когда вычисляется | Сколько раз вычисляется |
|----------------|-------------|-------------------|------------------------|
| `val` | Нет | Сразу при объявлении | Один раз |
| `var` | Да | Сразу при объявлении | Один раз (но можно переприсвоить) |
| `lazy val` | Нет | При первом обращении | Один раз |
| `def` | — | При каждом вызове | Каждый раз заново |

Разница между `lazy val` и `def` тонкая, но важная: `lazy val` запоминает результат после первого вычисления (кешируется), а `def` вычисляет заново при каждом обращении.

---

## Функции

Функции — это сердце любого языка программирования, и в Scala они занимают особое место. Давайте научимся их объявлять.

### Объявление функций

Простейшая функция выглядит так:

```scala
def square(x: Double) = x * x
```

Здесь `def` — ключевое слово для объявления функции, `square` — имя, `x: Double` — параметр с типом, а `x * x` — тело функции. Обратите внимание: мы не указали возвращаемый тип — компилятор вывел его сам (`Double`).

Функции можно использовать внутри других функций:

```scala
def area(radius: Double): Double =
  3.14159 * square(radius)

area(10)  // 314.159
```

Здесь мы указали возвращаемый тип `Double` явно. Это хорошая практика для публичных функций — так код становится понятнее для читателя.

### Функции с несколькими параметрами

Параметров может быть сколько угодно:

```scala
def sumOfSquares(
  x: Double,
  y: Double
) = square(x) + square(y)
```

### Сигнатура функции

**Сигнатура** — это «визитная карточка» функции: имя, типы параметров и возвращаемый тип. По сигнатуре можно понять, что функция делает, даже не заглядывая в реализацию:

```scala
def power(x: Double, y: Int): Double = ...
```

Из сигнатуры видно: функция принимает вещественное число и целое, возвращает вещественное. Скорее всего, это возведение в степень.

### Возврат значений

В Scala **последнее выражение** в теле функции автоматически становится возвращаемым значением. Ключевое слово `return` существует, но его использование не рекомендуется:

```scala
// С return (не рекомендуется — это не идиоматичный Scala)
def sum(a: Int, b: Int): Int = {
  return a + b
}

// Без return (идиоматично)
def sum(a: Int, b: Int): Int = {
  a + b
}

// Однострочная запись (ещё лучше, если тело простое)
def sum(a: Int, b: Int): Int = a + b
```

Почему `return` не рекомендуется? Потому что в Scala `return` — это не просто «верни значение», а фактически выброс исключения, что может привести к неожиданному поведению в лямбдах и вложенных функциях. Просто пишите нужное выражение последним — и всё будет работать.

---

## Условный переход и циклы

### Условный переход

Как мы уже говорили, `if/else` в Scala — это выражение, которое возвращает значение:

```scala
if (age < 18)
  "Underaged"
else
  "Adult"
```

Результат этого выражения можно присвоить переменной, передать в функцию, использовать как часть другого выражения — в общем, обращаться с ним как с любым другим значением.

### Цикл for

Цикл `for` позволяет пройтись по элементам коллекции:

```scala
val numbers = List(1, 2, 3)
for (n <- numbers) println(n)
```

Запись `n <- numbers` читается как «для каждого `n` из `numbers`». Стрелка `<-` — это генератор, который последовательно достаёт элементы из коллекции.

### foreach

То же самое можно сделать методом `foreach`, передав ему функцию:

```scala
val numbers = List(1, 2, 3)
numbers.foreach(n => println(n))
```

Здесь `n => println(n)` — это **анонимная функция** (лямбда). Она принимает элемент `n` и печатает его. Подробнее про лямбды мы поговорим на следующем уроке.

### for comprehension (yield)

А вот это по-настоящему мощная конструкция. Если вместо выполнения действия вы хотите **создать новую коллекцию** на основе существующей, используйте `yield`:

```scala
val numbers = List(1, 2, 3)
val doubledNumbers =
  for (n <- numbers) yield n * 2
// List(2, 4, 6)
```

`for ... yield` берёт каждый элемент, применяет к нему выражение и собирает результаты в новую коллекцию. Это очень похоже на метод `map`, с которым мы будем много работать в дальнейшем.

---

## Классы и типы

Пришло время поговорить о системе типов Scala. Это одна из самых продуманных систем типов среди современных языков программирования, и понимание её устройства — ключ к эффективному написанию кода.

### Иерархия типов в Scala

Все типы в Scala образуют чёткую иерархию. На вершине стоит тип `Any` — предок всех остальных типов. От него наследуются две ветви:

- **`AnyVal`** — примитивные типы, которые хранятся на стеке (в JVM — примитивы):
  `Double`, `Float`, `Long`, `Int`, `Short`, `Byte`, `Unit`, `Boolean`, `Char`

- **`AnyRef`** (эквивалент `java.lang.Object`) — ссылочные типы, которые хранятся в куче:
  `List`, `Option`, `String`, все ваши собственные классы

В самом низу иерархии находятся два особых типа:

- **`Null`** — подтип всех ссылочных типов, единственное значение — `null`
- **`Nothing`** — подтип абсолютно всех типов, у него **нет ни одного значения**

### Nothing — тип без значений

«Тип без значений» звучит странно. Зачем он нужен? `Nothing` обозначает вычисления, которые **никогда не завершаются нормально** — например, бросок исключения или бесконечный цикл:

```scala
def isTen(number: Int): Boolean =
  if (10 == number) true
  else throw new Exception("Number is not ten")
```

Здесь ветка `else` бросает исключение. Её тип — `Nothing`. Поскольку `Nothing` является подтипом всех типов (в том числе `Boolean`), компилятор без проблем принимает этот код: обе ветки `if` совместимы по типу.

В стандартной библиотеке есть удобная функция для подобных случаев:

```scala
// В стандартной библиотеке scala.sys
def error(message: String): Nothing =
  throw new RuntimeException(message)
```

### Null — наследие Java

`Null` — это тип, единственным значением которого является `null`. Он нужен для совместимости с Java, но в идиоматичном Scala-коде вы практически не будете его использовать:

```scala
val a: Null = null
object Nil extends List[Nothing]  // Пустой список
```

### Trait — абстрактный тип

Trait (трейт) — это конструкция, похожая на интерфейс в Java, но более мощная: трейт может содержать не только объявления методов, но и их **реализации**. Трейты — основной способ описания абстракций в Scala.

Простейший трейт может быть пустым (используется как маркер):

```scala
trait HairColor
```

Но чаще трейт объявляет набор методов, которые должны реализовать наследники:

```scala
trait Iterator {
  def hasNext: Boolean
  def next(): Int
}
```

Любой класс, наследующий `Iterator`, обязан предоставить реализации `hasNext` и `next`.

### Class — конкретный тип

Классы в Scala объявляются с помощью ключевого слова `class`. Параметры конструктора указываются прямо после имени класса:

```scala
class Vehicle(description: String) {
  println("constructing...")
  val name = description + " vehicle"
  def print(): Unit = println(name)
}
```

Обратите внимание: тело класса — это одновременно и тело конструктора. Строка `println("constructing...")` выполнится при создании каждого экземпляра.

По умолчанию параметры конструктора **приватны**. Чтобы сделать параметр доступным снаружи, добавьте `val`:

```scala
class Vehicle(val description: String) {
  println("constructing...")
  def print(): Unit = println(description)
}
```

Теперь можно обратиться к `vehicle.description` извне.

### Наследование (extends)

Наследование работает с помощью ключевого слова `extends`:

```scala
class Car extends Vehicle("heavy")
object FastCar extends Vehicle("fast")
trait FastCar extends Vehicle("fast")
```

Если нужно подмешать дополнительные трейты, используется `with`:

```scala
class Car extends Vehicle("heavy") with Foo
object FastCar extends Vehicle("fast") with Foo
trait FastCar extends Vehicle("fast") with Foo
```

Scala поддерживает **множественное наследование трейтов** (но не классов). Это позволяет гибко комбинировать поведение из разных источников.

### AnyVal (Value classes)

Напоследок — полезный приём. Иногда хочется создать тип-обёртку, чтобы не путать, скажем, имя пользователя с обычной строкой. Но создавать объект в куче ради этого расточительно. Тут на помощь приходят **value classes**:

```scala
class FirstName(val value: String) extends AnyVal
```

Такой класс во время выполнения «разворачивается» в обычный `String` — никакого дополнительного объекта в памяти не создаётся. При этом на этапе компиляции `FirstName` и `String` — разные типы, и компилятор не позволит вам передать одно вместо другого.

Ещё удобнее использовать `case class`:

```scala
case class FirstName(value: String) extends AnyVal
```

Что такое `case class` и почему он удобнее, мы подробно разберём в уроке про ADT и коллекции.

---

## Option

Помните, мы говорили про отказ от `null`? Вот конкретный механизм, который приходит ему на замену.

`Option` — это контейнер, который может находиться в одном из двух состояний:
- **`Some(value)`** — значение есть
- **`None`** — значения нет

Вот как это устроено внутри:

```scala
sealed abstract class Option[+A] { ... }

final case class Some[+A](value: A) extends Option[A] {
  def get: A = value
}

case object None extends Option[Nothing] {
  def get: Nothing = throw new NoSuchElementException("None.get")
}
```

Не пугайтесь синтаксиса — мы подробно разберём `sealed`, `case class` и `case object` в следующих уроках. Сейчас важна идея.

Вместо того чтобы возвращать `null`, когда значение не найдено, в Scala возвращают `Option`:

```scala
def findUser(id: Int): Option[User] = {
  // возвращает Some(user) если пользователь найден
  // или None если не найден
}

findUser(42) match {
  case Some(user) => println(s"Found: ${user.name}")
  case None       => println("User not found")
}
```

Красота этого подхода в том, что **тип не даёт забыть об обработке отсутствующего значения**. Если функция возвращает `Option[User]`, вы просто не сможете обратиться к полям пользователя, не «развернув» контейнер. Компилятор заставит вас обработать оба случая.

Это ваше первое знакомство с паттерном, который будет красной нитью проходить через весь курс: **кодирование информации в типах**. Чем больше знает система типов о вашей программе, тем больше ошибок она может предотвратить за вас.

---

## Структура проекта

Чтобы закрыть практическую сторону, давайте посмотрим, как выглядит типичный Scala-проект. Для сборки используется **sbt** (Scala Build Tool):

```
root/
├── build.sbt           # Конфигурация сборки (зависимости, версия Scala и т.д.)
├── project/
│   ├── build.properties # Версия sbt
│   └── plugins.sbt      # Плагины сbt
└── src/
    ├── main/
    │   └── scala/       # Здесь живёт ваш исходный код
    └── test/
        └── scala/       # А здесь — тесты
```

Файл `build.sbt` — это сердце проекта. В нём указывается версия Scala, зависимости от внешних библиотек и настройки сборки. Подробнее работу с sbt мы рассмотрим на практических занятиях.

---

## Итоги

В этом уроке мы прошли большой путь — от общих парадигм программирования до конкретного синтаксиса Scala. Вот ключевые идеи, которые стоит запомнить:

- Scala — **мультипарадигмальный** язык, но наш курс сфокусирован на функциональном подходе
- **Строгая типизация** с выводом типов — мощная система типов, которая не мешает писать лаконичный код
- **`val` — ваш друг по умолчанию**, `var` — только когда действительно нужно
- **Всё является выражением** и возвращает значение, включая `if/else`
- **Операторы — это методы**, что открывает интересные возможности для проектирования API
- **`Option` вместо `null`** — первый пример кодирования информации в типах

На следующем уроке мы глубоко погрузимся в функции — главный строительный блок функционального программирования. Вы узнаете про функции высшего порядка, каррирование, частичное применение и многое другое.

---

[← Назад к содержанию](../index.html)
