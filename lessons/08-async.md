---
layout: page
title: Асинхронное выполнение
---

# Асинхронное выполнение

В этой лекции мы рассмотрим фундаментальные концепции асинхронного и конкурентного программирования: конкурентность, параллелизм, многопоточность и асинхронность.

## Содержание
- [Определение конкурентности](#определение-конкурентности)
- [Max in flight](#max-in-flight)
- [Примеры конкурентности](#примеры-конкурентности)
- [Параллелизм](#параллелизм)
- [Конкурентность vs Параллелизм](#конкурентность-vs-параллелизм)
- [Способы достижения конкурентности](#способы-достижения-конкурентности)
- [Проблемы многопоточности](#проблемы-многопоточности)
- [Альтернатива многопоточности](#альтернатива-многопоточности)
- [Потоки в Scala (JVM)](#потоки-в-scala-jvm)
- [Thread Pool](#thread-pool)
- [ExecutionContext](#executioncontext)

---

## Определение конкурентности

### Этимология

> **Concurrent** — existing or happening at the same time.

Слово "concurrent" происходит от латинского *concurrere* — "сходиться, встречаться". В контексте вычислений это означает **одновременность**.

### Что такое конкурентность?

**Конкурентность** — это способность системы выполнять несколько задач одновременно (или создавать видимость одновременного выполнения).

```
Конкурентность = способность системы выполнять задачи конкурентно (одновременно)
```

### Распространённый миф

> **Миф:** Конкурентность — это когда кто-то конкурирует за что-то (например, потоки за процессорное время).

> **Разоблачение:** Конкурентность — это просто одновременность, но более научным языком.

### Важное уточнение о терминологии

| Русский термин | Английский термин | Значение |
|----------------|-------------------|----------|
| Конкурентность (одновременность) | Concurrency | Выполнение нескольких задач одновременно |
| Конкуренция | Competition | Соревнование за ресурсы |

Когда вы видите, как система выполняет несколько задач одновременно — это **конкурентное выполнение задач**.

При этом совершенно не важно, *как* именно системе удаётся это делать — с помощью нескольких процессоров, переключения между задачами или иным способом.

### Последовательное выполнение

Противоположность конкурентному выполнению — **последовательное выполнение**:

```
Последовательное выполнение = новая задача начинается строго после завершения предыдущей
```

```scala
// Последовательное выполнение
def sequential(): Unit = {
  task1()  // завершается
  task2()  // только потом начинается task2
  task3()  // только потом начинается task3
}
```

---

## Max in flight

### Измерение конкурентности

Конкурентность конкурентности рознь. Недостаточно просто сказать, что система конкурентная — нужно уточнять **степень конкурентности**.

**Max in flight** (максимальное количество задач в работе) — это метрика, показывающая, сколько задач система может выполнять одновременно.

```
Max in flight = максимальное число задач, выполняемых одновременно
```

### Примеры

| Система | Max in flight | Описание |
|---------|---------------|----------|
| Однопоточный сервер | 1 | Обрабатывает только один запрос |
| Веб-сервер с 10 worker'ами | 10 | До 10 запросов одновременно |
| Netflix | Тысячи | Тысячи клиентов смотрят видео одновременно |

Говорить просто, что "сервис конкурентный" — не имеет смысла. Надо уточнять степень конкурентности через Max in flight.

---

## Примеры конкурентности

Рассмотрим несколько примеров конкурентного выполнения задач в разных системах.

### Пример 1: Стриминговый сервис

С помощью Netflix несколько тысяч клиентов одновременно смотрят фильм.

| Параметр | Значение |
|----------|----------|
| **Задачи** | Предоставлять клиентам видео-поток фильма |
| **Исполнитель** | Сервис Netflix |
| **Max in flight** | Тысячи (или миллионы) |

### Пример 2: Снегопад

Во время снегопада миллионы снежинок падают одновременно.

| Параметр | Значение |
|----------|----------|
| **Задачи** | Передвигать миллионы снежинок гравитацией |
| **Исполнитель** | Вселенная |
| **Max in flight** | Миллионы |

### Пример 3: Многозадачность на компьютере

Человек на компьютере слушает музыку, общается в Telegram и играет в Hearthstone.

| Параметр | Значение |
|----------|----------|
| **Задачи** | Обслуживать несколько программ: Telegram, Hearthstone, браузер |
| **Исполнитель** | Компьютер (операционная система) |
| **Max in flight** | Десятки процессов |

---

## Параллелизм

### Параллелизм != Конкурентность

Это **два разных понятия**, которые часто путают.

### Определения

| Понятие | Определение |
|---------|-------------|
| **Конкурентность** | Внешняя видимость одновременного выполнения задач системой |
| **Параллелизм** | Внутренний механизм системы, позволяющий ускорить выполнение задач за счёт использования нескольких исполнителей |

### Ключевое различие

**Конкурентность** — это про *организацию* задач (возможность работать с несколькими задачами).

**Параллелизм** — это про *выполнение* задач (реальное одновременное выполнение на нескольких ядрах).

> Если бы из мира исчез параллелизм, всё, что мы бы потеряли — скорость наших систем.

### Способы ускорения CPU

Как можно ускорить выполнение программ на процессоре?

1. **Увеличение тактовой частоты процессора** — быстрее выполняем инструкции
2. **Улучшение архитектуры** — AVX инструкции, конвейеры, предсказание переходов
3. **Параллелизм** — распределение задач между несколькими исполнителями

### Параллелизм как способ ускорения

**Параллелизм** добивается ускорения за счёт распределения задач между исполнителями.

В современных системах исполнителями являются **ядра процессора** (или потоки). Именно за счёт них достигается параллельность и увеличивается производительность.

```
                    ┌─────────────────┐
                    │  Большая задача │
                    └────────┬────────┘
                             │
              ┌──────────────┼──────────────┐
              ▼              ▼              ▼
        ┌─────────┐    ┌─────────┐    ┌─────────┐
        │ Ядро 1  │    │ Ядро 2  │    │ Ядро 3  │
        │ Часть 1 │    │ Часть 2 │    │ Часть 3 │
        └────┬────┘    └────┬────┘    └────┬────┘
              │              │              │
              └──────────────┼──────────────┘
                             ▼
                    ┌─────────────────┐
                    │    Результат    │
                    └─────────────────┘
```

---

## Конкурентность vs Параллелизм

### Сравнительная таблица

| Конкурентность | Параллелизм | Пример |
|----------------|-------------|--------|
| + | - | ОС на одном ядре, JavaScript |
| - | + | Последовательное выполнение задач группой исполнителей |
| + | + | Раздать множество группе исполнителей, чтобы они выполняли их конкурентно |
| - | - | Последовательное выполнение на одном ядре |

### Разбор примеров

#### Конкурентность есть, параллелизма нет

**Пример:** Операционная система на одноядерном процессоре, JavaScript.

Система создаёт **видимость** одновременного выполнения (конкурентность), но физически задачи выполняются по очереди на одном ядре (нет параллелизма).

```
Ядро:  [Задача1][Задача2][Задача1][Задача3][Задача2]...
       ─────────────────────────────────────────────────▶ время
```

#### Параллелизм есть, конкурентности нет

**Пример:** Последовательное выполнение задач группой исполнителей.

Несколько исполнителей работают параллельно, но каждый выполняет одну задачу от начала до конца.

```
Ядро 1: [Задача 1]
Ядро 2: [Задача 2]
Ядро 3: [Задача 3]
        ─────────────────────────────────────────────────▶ время
```

#### Есть и конкурентность, и параллелизм

**Пример:** Раздать множество задач группе исполнителей для конкурентного выполнения.

Несколько ядер обрабатывают множество задач, переключаясь между ними.

```
Ядро 1: [T1][T4][T1][T7]...
Ядро 2: [T2][T5][T2][T8]...
Ядро 3: [T3][T6][T3][T9]...
        ─────────────────────────────────────────────────▶ время
```

#### Нет ни конкурентности, ни параллелизма

**Пример:** Последовательное выполнение на одном ядре.

```
Ядро:  [Задача 1][Задача 2][Задача 3]
       ─────────────────────────────────────────────────▶ время
```

---

## Способы достижения конкурентности

### Конкурентность через многопоточность

Самый прямолинейный способ добиться конкурентности — использовать **многопоточность**.

```
Max in flight = количество рабочих потоков (worker threads)
```

**Правило:** Хочешь выполнять N задач одновременно — придётся держать N потоков.

```scala
// Пример: обработка запросов в многопоточном режиме
val executor = Executors.newFixedThreadPool(10) // 10 потоков

for (request <- requests) {
  executor.submit(new Runnable {
    def run(): Unit = processRequest(request)
  })
}
```

### Параллелизм через многопоточность

Чтобы получить все бонусы от параллелизма:

```
Достаточно создать потоков = количеству ядер!
```

Если у вас 8 ядер, создайте 8 потоков — и все ядра будут загружены работой.

```scala
val cores = Runtime.getRuntime.availableProcessors()
val executor = Executors.newFixedThreadPool(cores)
```

---

## Проблемы многопоточности

### Почему многопоточность — не идеальное решение?

Многопоточность имеет ряд существенных проблем:

#### 1. Создание потоков — дорогая операция

Создание нового потока в JVM включает:
- Выделение памяти для стека потока (обычно 512KB - 1MB)
- Системные вызовы к ОС
- Регистрация потока в планировщике

```scala
// Каждый new Thread() — это дорого!
val thread = new Thread(() => doWork())
thread.start()
```

#### 2. Потоки занимают много памяти

Каждый поток требует память для своего стека:

| Количество потоков | Память только на стеки |
|--------------------|------------------------|
| 100 потоков | ~100 MB |
| 1000 потоков | ~1 GB |
| 10000 потоков | ~10 GB |

#### 3. Переключение контекста замедляет работу

Когда ОС переключается между потоками (context switch), происходит:
- Сохранение состояния текущего потока
- Загрузка состояния нового потока
- Инвалидация кэшей процессора

Чем больше потоков — тем больше переключений — тем медленнее работает система.

#### 4. Есть лимит на количество потоков

Операционная система ограничивает максимальное число потоков на процесс.

### Выводы о многопоточности для конкурентности

| Проблема | Влияние |
|----------|---------|
| Дорогое создание потоков | Высокая latency при создании новых задач |
| Большое потребление памяти | Ограниченный Max in flight |
| Context switching overhead | Падение производительности |
| Системные лимиты | Жёсткие ограничения на масштабирование |

**Вывод:** Получать конкурентность через многопоточность — очень дорого. Излишние потоки накладывают значительный штраф на производительность приложения.

---

## Альтернатива многопоточности

### Идеальная многопоточность

Что хотелось бы иметь:

1. **Создавать потоки как можно реже**
   - Выход: переиспользовать потоки

2. **Иметь потоков как можно меньше**
   - Количество потоков = количеству ядер
   - Получаем все бонусы параллелизма, не ухудшая производительность лишними потоками

### Анализ структуры задач

Из каких сегментов состоит типичная серверная задача (например, обработка HTTP-запроса)?

```
1. Установка соединения      ─┐
2. Парсинг запроса            │
3. Авторизация пользователя   │── Что здесь происходит?
4. Проверка корректности      │
5. Запись сообщения в базу    │
6. Отправка ответа           ─┘
```

### Виды задач по характеру нагрузки

| Тип задачи | Характеристика | Примеры |
|------------|----------------|---------|
| **CPU-bound** | Преобладают вычисления | Арифметика, перемножение матриц, ML, алгоритмы |
| **IO-bound** | Преобладает ожидание ввода-вывода | Запись на диск, сетевые запросы, работа с БД |

### Экономия на IO-bound задачах

**Важный факт:** Большинство задач в современных сервисах — **IO-bound**.

Во время выполнения IO-bound операции (запрос к базе данных, HTTP-запрос) основной поток **ничего не делает** — он просто ждёт ответа.

```
Поток:  [Работа][    Ожидание IO    ][Работа][    Ожидание IO    ]
                ▲                           ▲
                │                           │
                └── Поток мог бы делать что-то другое!
```

**Идея:** Пока поток ждёт IO, он может пойти заниматься чем-то другим!

### Асинхронность

**Асинхронность** — это модель выполнения, при которой поток не блокируется во время ожидания IO-операций, а переключается на выполнение других задач.

```
                    Синхронное выполнение
Поток 1: [Запрос 1: работа][ожидание БД][обработка]
Поток 2: [Запрос 2: работа][ожидание БД][обработка]
Поток 3: [Запрос 3: работа][ожидание БД][обработка]

                    Асинхронное выполнение
Поток 1: [Р1][Р2][Р3][обр.Р1][обр.Р2][обр.Р3]
         │    │   │      ▲       ▲      ▲
         │    │   │      │       │      │
         └────┴───┴──────┴───────┴──────┘
              Один поток обрабатывает всё!
```

### Идеальная модель

Комбинация многопоточности и асинхронности:

| Компонент | Настройка | Преимущество |
|-----------|-----------|--------------|
| Многопоточность | Число потоков = числу ядер | Полная загрузка CPU (параллелизм) |
| Асинхронность | Потоки не блокируются на IO | Высокий Max in flight без лишних потоков |

```scala
// Идеальная конфигурация
val threadPool = Executors.newFixedThreadPool(
  Runtime.getRuntime.availableProcessors()
)

// + асинхронные операции вместо блокирующих
def fetchData(): Future[Data] = ???  // не блокирует поток
```

---

## Потоки в Scala (JVM)

### Создание потока

```scala
def someTask(): Unit = {
  // ... выполнение задачи
}

val thread = new Thread(() => someTask())

thread.start() // поток пошёл выполняться и делать задачу
```

### Пример с несколькими потоками

```scala
def printNumbers(name: String): Unit = {
  for (i <- 1 to 5) {
    println(s"$name: $i")
    Thread.sleep(100)
  }
}

val thread1 = new Thread(() => printNumbers("Thread-1"))
val thread2 = new Thread(() => printNumbers("Thread-2"))

thread1.start()
thread2.start()

// Вывод будет чередоваться:
// Thread-1: 1
// Thread-2: 1
// Thread-1: 2
// Thread-2: 2
// ...
```

### Проблема: создание потоков дорого

```scala
// Плохо: создаём новый поток на каждую задачу
def handleRequest(request: Request): Unit = {
  val thread = new Thread(() => process(request))
  thread.start()
}
// При 10000 запросов в секунду — 10000 новых потоков!
```

### Решение: переиспользование потоков

**Потоки создавать дорого. Убивать потоки — расточительно.**

Вместо создания нового потока на каждую задачу, используем **пул потоков**.

---

## Thread Pool

### Концепция

**Thread Pool** (пул потоков) — это набор заранее созданных потоков, которые переиспользуются для выполнения задач.

```
                    ┌─────────────────────────────┐
                    │        Thread Pool          │
                    │  ┌───┐ ┌───┐ ┌───┐ ┌───┐   │
 Задачи ──────────▶ │  │ T │ │ T │ │ T │ │ T │   │
                    │  └───┘ └───┘ └───┘ └───┘   │
                    │         ▲                   │
                    │         │                   │
                    │  ┌──────┴───────┐          │
                    │  │ Work Queue   │          │
                    │  │ [задача][задача][...]   │
                    │  └──────────────┘          │
                    └─────────────────────────────┘
```

### Алгоритм работы потока в пуле

```
loop {
  1. Проверь очередь задач
  2. Если в очереди есть задача — выполняй её
  3. Если задачи нет — повторяй алгоритм (или засыпай)
}
```

### ThreadPoolExecutor в Java (и Scala)

```scala
import java.util.concurrent.ThreadPoolExecutor

class ThreadPoolExecutor(
  corePoolSize: Int,      // минимальное число потоков
  maximumPoolSize: Int,   // максимальное число потоков
  keepAliveTime: Long,    // через сколько убить неактивный поток
  unit: TimeUnit,         // единица измерения времени
  workQueue: BlockingQueue[Runnable], // очередь задач
  threadFactory: ThreadFactory        // фабрика для создания потоков
)
```

| Параметр | Описание |
|----------|----------|
| `corePoolSize` | Сколько потоков по умолчанию (минимальное число) |
| `maximumPoolSize` | Максимальное число потоков |
| `keepAliveTime` | Через сколько времени убить неактивный поток |
| `workQueue` | Очередь задач |
| `threadFactory` | Фабрика потоков (с её помощью ThreadPool заполняется потоками) |

### Типы Thread Pool

#### 1. Fixed Thread Pool

```scala
val fixedPool = Executors.newFixedThreadPool(4)
```

| Параметр | Значение |
|----------|----------|
| `corePoolSize` | N |
| `maximumPoolSize` | N |

**Характеристики:**
- Число потоков фиксированное, неизменное
- Если один из потоков умирает — ему на замену тут же создаётся новый

**Когда использовать:** Когда нужно ограниченное и предсказуемое число потоков.

#### 2. Cached Thread Pool

```scala
val cachedPool = Executors.newCachedThreadPool()
```

| Параметр | Значение |
|----------|----------|
| `corePoolSize` | 0 |
| `maximumPoolSize` | Int.MaxValue |
| `keepAliveTime` | 60 seconds |

**Характеристики:**
- Изначально потоков 0
- Потоки без работы умирают через минуту
- Если свободных потоков не хватает — создаётся новый (вплоть до бесконечности)

**Когда использовать:** Для коротких асинхронных задач. Осторожно — может создать слишком много потоков!

#### 3. Single Thread Executor

```scala
val singleThread = Executors.newSingleThreadExecutor()
```

**Характеристики:**
- Ровно один поток
- Гарантирует последовательное выполнение задач

**Когда использовать:** Когда задачи должны выполняться строго последовательно.

#### 4. Scheduled Thread Pool

```scala
val scheduledPool = Executors.newScheduledThreadPool(4)

// Выполнить задачу через 5 секунд
scheduledPool.schedule(() => println("Hello!"), 5, TimeUnit.SECONDS)

// Выполнять задачу каждые 10 секунд
scheduledPool.scheduleAtFixedRate(() => println("Tick"), 0, 10, TimeUnit.SECONDS)
```

**Когда использовать:** Для отложенных и периодических задач.

---

## ExecutionContext

### Абстракция над пулом потоков в Scala

В Scala для абстракции над механизмом выполнения задач используется `ExecutionContext`:

```scala
trait ExecutionContext {
  def execute(runnable: Runnable): Unit

  def reportFailure(cause: Throwable): Unit
}
```

### Стандартный ExecutionContext

```scala
import scala.concurrent.ExecutionContext

// Глобальный ExecutionContext (используется по умолчанию)
implicit val ec: ExecutionContext = ExecutionContext.global
```

`ExecutionContext.global` — это ForkJoinPool с числом потоков, равным числу ядер процессора.

### Создание собственного ExecutionContext

```scala
import java.util.concurrent.Executors
import scala.concurrent.ExecutionContext

// Из ThreadPoolExecutor
val threadPool = Executors.newFixedThreadPool(10)
implicit val ec: ExecutionContext = ExecutionContext.fromExecutor(threadPool)

// Из ExecutorService
val executor = Executors.newCachedThreadPool()
implicit val ec: ExecutionContext = ExecutionContext.fromExecutorService(executor)
```

### Проблема: как получить результат?

`ExecutionContext.execute` принимает `Runnable`, который возвращает `Unit`:

```scala
trait Runnable {
  def run(): Unit  // Как вернуть значение?
}
```

**Вопросы:**
1. Как выполнять функции, возвращающие значения?
2. Как достать это значение?

**Ответ:** Для этого существует `Future` — тип, представляющий результат асинхронного вычисления. Об этом подробнее в следующей лекции.

```scala
import scala.concurrent.Future
import scala.concurrent.ExecutionContext.Implicits.global

// Future позволяет вернуть значение из асинхронного вычисления
val futureResult: Future[Int] = Future {
  // Вычисление выполняется в другом потоке
  expensiveComputation()
}

// Результат можно обработать с помощью map/flatMap
futureResult.map(result => println(s"Результат: $result"))
```

---

## Резюме

В этой лекции мы изучили:

1. **Конкурентность** — способность системы выполнять несколько задач одновременно (или создавать такую видимость)

2. **Параллелизм** — механизм ускорения за счёт использования нескольких исполнителей (ядер)

3. **Max in flight** — метрика степени конкурентности системы

4. **Многопоточность** — способ достижения конкурентности, имеющий существенные накладные расходы

5. **Асинхронность** — модель, позволяющая не блокировать потоки во время IO-операций

6. **Thread Pool** — механизм переиспользования потоков для эффективного выполнения задач

7. **ExecutionContext** — абстракция над пулом потоков в Scala

### Ключевые выводы

| Концепция | Вывод |
|-----------|-------|
| Конкурентность vs Параллелизм | Это разные понятия: конкурентность — про организацию, параллелизм — про ускорение |
| Многопоточность | Дорогой способ получить конкурентность |
| Идеальное решение | Потоков = ядрам + асинхронные IO-операции |
| Thread Pool | Позволяет переиспользовать потоки |

### Что дальше?

В следующей лекции мы рассмотрим `Future` — основной инструмент для асинхронного программирования в Scala, который позволяет работать с результатами асинхронных вычислений в функциональном стиле.

---

[← Назад к содержанию](../index.html)
